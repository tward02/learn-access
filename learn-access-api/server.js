import express from 'express';
import {exec} from 'child_process';
import fs from 'fs';
import path from 'path';
import {v4 as uuidv4} from 'uuid';
import morgan from "morgan";
import {sql} from "@vercel/postgres";
import dotenv from "dotenv";
import util from 'util';
import cors from "cors";

dotenv.config();

//used to execute tests in parallel
const execPromise = util.promisify(exec);

const app = express();
app.use(express.json());
//enables requests to come in from the frontend domain without being rejected by CORS
app.use(cors({origin: process.env.FRONTEND_DOMAIN}));
app.use(morgan("dev"));

//test endpoint
app.get("/hello", (req, res) => {
    res.status(200).json({message: "Hello, World!"});
});

//HTML code used to render the React component sent from the frontend in order for playwright tests to be executed on it, CDN used to fetch libraries for efficiency
//adapted from https://www.w3schools.com/react/react_render.asp
const getPlaywrightRender = (reactCode, css) => `
<html lang="en">
        <head>
            <title>test</title>
            <style>${css}</style>
            <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.development.js"></script>
            <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.development.js"></script>
            <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.22.5/babel.min.js"></script>
        </head>
        <body>
            <div id="root"></div>
            <script type="text/babel">
                ${reactCode}
                ReactDOM.createRoot(document.getElementById('root')).render(React.createElement(App));
            </script>
        </body>
</html>
`

//rejects any code that is attempting to do harm to the testing endpoints
function isSafeReactCode(code) {
    const forbiddenPatterns = [
        /\bfs\b/,
        /\bpath\b/,
        /\bchild_process\b/,
        /\bhttp\b/,
        /\bhttps\b/,
        /\bnet\b/,
        /\bdgram\b/,
        /\bfetch\s*\(/,
        /\baxios\s*\(/,
        /\bXMLHttpRequest\b/,
        /\brequire\s*\(/,
        /\bprocess\b/,
        /\bBuffer\b/,
        /\bcrypto\b/,
        /\bvm\b/,
        /\bworker_threads\b/,
        /\bcluster\b/
    ];

    //helped generated by https://regex101.com/
    const stringAndHtmlRegex = /(['"`])([^\\\1]|\\.)*\1|<[^>]*>/g;

    const codeWithoutStringsOrHtml = code.replace(stringAndHtmlRegex, '');

    return !forbiddenPatterns.some(pattern => pattern.test(codeWithoutStringsOrHtml));
}

//accesses the database in order to authenticate user
const getUserById = async (id) => {
    const {rows} = (await sql`
        SELECT id, username, password
        FROM users
        WHERE id = ${id};`);

    return rows[0];
}

//fetches tests from database to be executed on the sent code
const getTests = async (levelId) => {
    const {rows} = (await sql`
        SELECT *
        from level_tests
        WHERE levelId = ${levelId};
    `)
    rows.map((test) => {
        test.code = test.code.replace(/\\n/g, '\n');
    })
    return rows;
}

//gets level from database as well as whther it is availible to the user so that we can authenticate them
export const getLevel = async (userId, levelId) => {
    const result = await sql`
        WITH user_completed_levels AS (SELECT levelID
                                       FROM user_levels
                                       WHERE userID = ${userId})
        SELECT l.id                                                                   AS id,
               l.name,
               l.description,
               l.objectives,
               l.expiration,
               l.enhancedDescription,
               COALESCE(ul.levelID IS NOT NULL, FALSE)                                AS completed,
               COALESCE(l.previousLevelId IS NOT NULL AND upl.levelID IS NULL, FALSE) AS locked
        FROM levels l
                 LEFT JOIN user_completed_levels ul ON l.id = ul.levelID
                 LEFT JOIN user_completed_levels upl ON l.previousLevelId = upl.levelID
        WHERE l.id = ${levelId};`

    return result.rows;
}

export const passLevel = async (userId, levelId) => {
    await sql`
        INSERT INTO user_levels (userID, levelID, datetime)
        VALUES (${userId}, ${levelId}, NOW())
    `;
}

const authenticate = async (user) => {
    const dbUser = await getUserById(user.id);

    if (!dbUser) {
        return false;
    }

    return user.password === dbUser.password;
}

//searches for things defined as template literals (``) and converts them to regular strings so that code can be rendered correctly for playwright tests helped by https://regex101.com/
const convertTemplateLiteralsToStrings = (code) => {
    return code.replace(/`([^`]*?)`/g, (match, content) => {
        const transformedContent = content.replace(/\$\{([^}]+)\}/g, '" + $1 + "');
        return `"${transformedContent}"`;
    });
}

const runJestTest = async (testDir, test, index) => {
    //creates test file to be run on code
    const testPath = path.join(testDir, 'App' + index + '.test.js');
    fs.writeFileSync(testPath, test.code);

    const resultList = [];

    try {
        //runs test file on code parses JSON results into format to be returned by endpoint
        const {stdout} = await execPromise(`npx jest --config jest.config.js --findRelatedTests ${path.normalize(testPath)} --json`);
        const results = JSON.parse(stdout);
        //if passed then generate passed tests json
        results.testResults.forEach((tests) => {
            tests.assertionResults.forEach(testResult => {
                resultList.push({
                    passed: (testResult.status === "passed"),
                    suite: test.name,
                    name: testResult.fullName,
                    type: test.type
                });
            })
        })
    } catch (error) {
        if (error.stdout) {
            //if tests failed find tests that fialed and message reason and also find tests that passed and add to response json
            const results = JSON.parse(error.stdout);
            results.testResults.forEach((tests) => {
                tests.assertionResults.forEach(testResult => {
                    const passed = testResult.status === "passed";
                    const resultObject = {passed: passed, suite: test.name, name: testResult.fullName, type: test.type};
                    if (!passed) {
                        resultObject.message = testResult.failureMessages;
                    }
                    resultList.push(resultObject);
                })
            })
        } else {
            //if tests suite failed to run then return generic message
            resultList.push({passed: false, suite: test.name, message: "Error running Jest", type: test.type});
        }
    }
    return resultList;
}

//transforms React imports such as useEffect etc in format: import React, {useEffect, useState} from 'react' into const {useEffect, useState} = React so that code can be rendered for playwright tests
//helped by https://regex101.com/
const transformReactImports = (source) => {

    const importRegex = /^import\s+(?:React,\s*)?\{\s*([^}]+?)\s*}\s+from\s+["']react["'];?$/gm;

    return source.replace(importRegex, (match, hooksGroup) => {
        const hooksList = hooksGroup.split(",").map(hook => hook.trim());
        return `const { ${hooksList.join(", ")} } = React;`;
    });
}


const runPlaywrightTest = async (testDir, test, code, css, index) => {
    //creates playwright test file
    const testPath = path.join(testDir, 'playwrightTest' + index + '.spec.js');

    //removes any unnecessary code from user React file so that it can be rendered and tested on by playwright correctly
    let formattedCode = transformReactImports(code);
    formattedCode = formattedCode.replaceAll("import React from \'react\'", "")
    formattedCode = formattedCode.replaceAll("import React from \"react\"", "")
    formattedCode = formattedCode.replaceAll("import React from \"react\"", "")
    formattedCode = formattedCode.replaceAll("import \'./styles.css\'", "")
    formattedCode = formattedCode.replaceAll("import \"./styles.css\"", "")
    formattedCode = formattedCode.replace("export default App", "")
    formattedCode = formattedCode.replaceAll("export default", "");
    formattedCode = formattedCode.replaceAll("export", "");
    formattedCode = convertTemplateLiteralsToStrings(formattedCode);

    //adds user code into playwright tests
    const render = getPlaywrightRender(formattedCode, css);
    const testCode = test.code.replaceAll("///Render///", render);
    fs.writeFileSync(testPath, testCode);

    const resultList = [];

    try {
        //runs playwright tests using console command and return results as JSON
        const {stdout} = await execPromise(`npx playwright test ${testPath.replace(/\\/g, "/")} --reporter=json`);
        //if pass then parse json results and process al tests into repsosne object
        const results = JSON.parse(stdout);
        results.suites.forEach((suite) => {
            suite.specs.forEach(spec => {
                spec.tests.forEach((testResult) => {
                    resultList.push({
                        passed: testResult.results[0].status === "passed",
                        suite: test.name,
                        name: spec.title,
                        type: test.type
                    });
                })
            })
        })
    } catch (error) {
        if (error.stdout) {
            //if fail then loop through all tests, pass json and extract failed tests and error messages as well as extracting passed tests, add all to repsonse object
            const results = JSON.parse(error.stdout);
            results.suites.forEach((suite) => {
                suite.specs.forEach(spec => {
                    spec.tests.forEach((testResult) => {
                        const passed = testResult.results[0].status === "passed";
                        const resultObj = {passed: passed, suite: test.name, name: spec.title, type: test.type};
                        if (!passed) {
                            resultObj.message = testResult.results[0].error.message;
                        }
                        resultList.push(resultObj);
                    })
                })
            })
        } else {
            //if tests fail to run add egeric message to response object
            resultList.push({passed: false, suite: test.name, message: "Error running Playwright", type: test.type});
        }
    }
    return resultList;
}

//runs a particular level's tests on a user's code
const runTests = async (levelId, code, css) => {
    //creates user code files in unique directory so that multiple users can run tests at same time
    const tempDir = path.join("testing", 'temp', uuidv4());
    fs.mkdirSync(tempDir, {recursive: true});

    const appPath = path.join(tempDir, 'App.js');
    const cssPath = path.join(tempDir, 'styles.css');

    let jestCode = code;

    //adds correct imports to code to be testsed by jest
    if (!code.includes("import React from \'react\'") && !code.includes("import React from \"react\"") && !code.includes("import React")) {
        jestCode = "import React from \'react\';\n" + jestCode;
    }

    if (!code.includes("import \'./styles.css\'\n") && !code.includes("import \"./styles.css\"\n")) {
        jestCode = "import \'./styles.css\'\n" + jestCode;
    }

    //writes files with code
    fs.writeFileSync(appPath, jestCode);
    fs.writeFileSync(cssPath, css);

    const tests = await getTests(levelId);

    //loops through all test suites and executes them in parallel adding their results to a list
    const results = await Promise.all(
        tests.map((test, index) => {
            if (test.type === "jest") {
                return runJestTest(tempDir, test, index);
            } else if (test.type === "playwright") {
                return runPlaywrightTest(tempDir, test, code, css, index);
            }
        })
    );

    //removes all tests and user code - cleanup and return response object
    fs.rmSync(tempDir, {recursive: true, force: true});
    return results.flatMap(subArray => subArray);
}

//TODO when deploying run npx playwright install

//handles running tests and passing the level when suer presses the "submit" button
app.post('/submit/:levelId', async (req, res) => {

    //validates request body
    let {code, css, user} = req?.body?.data;
    const levelId = await req?.params?.levelId;

    if (!user || !await authenticate(user)) {
        return res.status(401).json({message: 'Not Authenticated'});
    }

    const levelData = await getLevel(user.id, levelId);
    if (levelData.length === 0) {
        return res.status(404).json({message: 'Level Not Found'});
    }

    if (levelData[0].locked === true) {
        return res.status(403).json({message: 'You don\'t have permission to do this level'});
    }

    if (!code) {
        return res.status(400).json({message: 'Missing Required Attribute'});
    }

    if (!css) {
        css = "";
    }

    //run tests
    const testResultsList = await runTests(levelId, code, css);

    //process results and add level pass result to db is all tests pass
    let passed = true;
    testResultsList.forEach(test => {
        passed = test.passed && passed;
    })

    if (passed) {
        await passLevel(user.id, levelId);
    }

    if (testResultsList.length === 0) {
        passed = false;
    }

    res.status(200).json({success: passed});
});

//handles running tests when user presses the "test" button
app.post('/test/:levelId', async (req, res) => {

    //validates request
    let {code, css, user} = req?.body?.data;
    const levelId = await req?.params?.levelId;

    if (!user || !await authenticate(user)) {
        return res.status(401).json({message: 'Not Authenticated'});
    }

    const levelData = await getLevel(user.id, levelId);
    if (levelData.length === 0) {
        return res.status(404).json({message: 'Level Not Found'});
    }

    if (levelData[0].locked === true) {
        return res.status(403).json({message: 'You don\'t have permission to do this level'});
    }

    if (!code) {
        return res.status(400).json({message: 'Missing Required Attribute'});
    }

    if (!isSafeReactCode(code)) {
        return res.status(400).json({message: 'Your React code failed to compile or is unsafe'});
    }

    if (!css) {
        css = "";
    }

    //runs tests and returns results
    const testResultsList = await runTests(levelId, code, css);

    let passed = true;
    testResultsList.forEach(test => {
        passed = test.passed && passed;
    })

    if (testResultsList.length === 0) {
        passed = false;
    }

    res.status(200).json({passed: passed, tests: testResultsList});
});

if (process.env.NODE_ENV !== 'test') {
    app.listen(4000, () => console.log('Server running on port 4000'));
}

export default app;
